# [Graph Traverser](https://graph-traverser.netlify.app/)

This is a mini project in typescript (using vite), using html canvas for traversing a graph in matrix or maze representation and visulaizing the path from `source` to `destination` generated by the selected algorithm. The graph can be traversed using Breadth-first Search, Depth-first Search, Uniform-cost Search, A\* Search which are implemented in this project. Along with the algorithms, data structures used in these algorithms such as Stack, Queue, and Heap are also implemented.

_Note_ - If there is any errors in algorithm implementations, let me know and I will rectify it, or feel free to do so.

### Live Link: https://graph-traverser.netlify.app/

<div align="center">
<img alt="logo" src="/public/logo.png" width="100" height="100">
</div>

<table>
    <tr>
        <td><img alt="reguular graph" src="/readme_images/reg-graph.png"/></td>
        <td><img alt="reguular graph" src="/readme_images/maze.png"/></td>
        <td><img alt="reguular graph" src="/readme_images/weigthed.png"/></td>
    </tr>
</table>

##### Inspiration:

I got my inspiration to work on this project after watching this [youtube video](https://www.youtube.com/watch?v=n4t_-NjY_Sg) by [Cl√©ment Mihailescu](https://www.youtube.com/@clem). Although I watched it 4 years back, I finally made a project around this time.

##### Run this project locally:

1. Clone the repository:

```bash
git clone
```

2. Change to the project directory:

```bash
cd graph-traverser
```

3. Install dependencies:

```bash
npm install
```

4.Start the development server:

```bash
npm run dev
```

##### Features:

![features](readme_images/features.png)

- `Algorithm`: Select any one of the algorithms from the dropdown to visualize the traverser.

- `Graph Type`: Select one of the graph types - **Regular**, **Maze**, **Weighted** graphs. Selection creates a new graph.

- `Node Type`: Graphs can have either **Square** or **Circle** representaions.

- `Cell Width`: This is a input field that can be used to change the cell width of each node. This changes the appearance of the graph as a lower cell width results is more nodes. Default value is `30` and the supported range is `[15, 40]`.

- `Regenerate`: Button to regenerate the entire graph.

- `Start`: Starts the selected traversal if the source and destination nodes are selected.

- `Add walls`: Users can add walls by draggin mouse around a **regular** and **weighted** graph to block the patch of the traversal. Walls cannot be added in mazes.

##### Graph representations.

For more details on the implementaion of graphs, check `graph.ts` for implementaion details.

1. `Regular Graph`: This is a regular matrix with all values filled with 1. This is to visualize how different algorithms work when the weight of the nodes are equal. Select the source and destination to visualize the working of supported algorithms.
   Sample gif of algorithms in a regular graph with and without walls.

   <table style="width:100%; display: flex; justify-content: center">
   <tr>
       <td>
       <img width="300" height="300" src="./readme_images/reg-graph-action.gif" alt="regular_graph_bfs">
       </td>
       <td>
       <img width=300" height="300" src="./readme_images/reg-graph-walls.gif" alt="regular_graph_bfs">
       </td>
   </table>

2. `Maze`: As the name suggests a maze is generated for traversal. Walls are represented by value 1 and path to traverse by 0. Initially, a regular graph is initiated, i.e a graph with all values equal to 1. `Dfs` algorithm is run from a random row in the first column and the dfs visits every alternating neigbor rather than the adjacent neighbor, and the adjecent neighbor is marked visited to connect the path of the maze.

   - I watched a youtube video [Create a Maze Generator in JavaScript in 20 minutes!](https://www.youtube.com/watch?v=Pm0BFtQH_7Y), that shows how to create a maze.

   Sample gif of `dfs` in a maze.

    <div align="center">
       <img src="./readme_images/maze-graph-action.gif" alt="regular_graph_bfs">
   </div>

3. `Weighted Graph`: Similar to regular graph, but each node has a different weight spanning from 1 to 10. This graph is added to visualize how different algorithms especially (a\*, ucs) work in weighted graph.

   Sample gif of algorithms in a weighted graph with and without walls.

   <table style="width:100%; display: flex; justify-content: center">
    <tr>
    <td><img width="300" height="300" src="./readme_images/weighted-graph-action.gif" alt="regular_graph_bfs">
    </td>
    <td><img width="300" height="300" src="./readme_images/weighted-graph-walls.gif" alt="regular_graph_bfs">
    </td>
    </tr>
   </table>

##### Supported Algorithms:

For more details on the implementaion of traversal, check **traverse()** method in `traversal.ts` for implementaion details.

- `Breadth-first Search (BFS)`: A classic graph algorithm used to visit all the neighbors level wise. Uses a queue data structure. In this project I am using queue data structure, but don't run a seperate loop to traverse all the neighbors first level by level, rather regular bfs.

- `Depth-first Search (BFS)`: Another classical graph algorithm used to visit all neighbors depth wise. Uses a stack data structure.

- `Uniform-cost Search (UCS)`: One of the search algorithms, that uses **priority queues** for exploring nodes. It also adds the runnig cost of each node to find optimal path. Also, it uses **min-heap** as a priority queue, but I have also added **max-heap** as well for experimental purposes.

- `A* Search`: Does the same as Uniform-cost Search, but adds the distance between the node being explored and destination, so that more weightage is given to shorted distances and speeds up the exploring time. I have used `Manhattan distance` for calculating distances between two nodes. No support for euclidean distance as of now.

- **Note: All the algorithms I have implemented is from my knowledge of how theses algorithms work. If you find any mistakes or discrepancis between the algorithms, feel free to rectify it.**

##### Resources Used:

- [Animating HTML5 Canvas for Complete Beginners (
  Chris Courses
  )](https://www.youtube.com/playlist?list=PLpPnRKq7eNW3We9VdCfx9fprhqXHwTPXL) - For learning basic canvas functionalities.
- [Create a Maze Generator in JavaScript in 20 minutes!](https://www.youtube.com/watch?v=Pm0BFtQH_7Y) - Maze generation
- [Design.com](https://www.design.com/) - Used to create the logo for the application.
- [Ezgif](https://ezgif.com/) - Used to create the GIFs for the README file.
- [Netlify](https://www.netlify.com/) - Used to deploy the application.
- Cluade - Used for generation of color codes in the application.
- LLMs in general to fix bugs during development.
